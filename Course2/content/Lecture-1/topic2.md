# Глава 2: Основы синтаксиса языка С

## 2.1 Типы данных и переменные

Для начала нам хватит такого набора примитивных типов данных:

* `int` — целое число;
* `double` — вещественное число;
* `char` — символ.

Позже мы расширим доступный нам спектр типов.

Объявление переменной какого-то типа делается вот так:
`имя_типа имя_переменной;`

Можно использовать константные значения типов `int`/`double`/`char` в коде (их ещё называют «литералы»):

```c
int x;
x = 773;

double y;
y = -13.513;

char z;
z = '*';
```

Обратите внимание, что литерал типа `char` заключается в одинарные кавычки. Двойные кавычки для этого использовать нельзя, они имеют другой смысл\!

Переменную можно инициализировать сразу же в момент её объявления:
`int x = 5;`

Также допустимо объявление нескольких переменных в одной строке:
`int x1 = 5, x2, x3 = 0;`

Читать и писать переменные разного типа можно делать с помощью функций `scanf` и `printf`:

```c
// Читаем и пишем int:
scanf("%d", &x); 
printf("%d", x);

// Читаем и пишем double:
scanf("%lf", &y); 
printf("%lf", y);

// Читаем и пишем char:
scanf("%c", &z); 
printf("%c", z);
```

Обратите внимание, на символ «&» перед именем переменной в `scanf`. Он должен здесь стоять, без него программа работать будет некорректно. Смысл этого символа станет ясен чуть позже, когда мы будем разбираться с указателями.

Также важно заметить, что при чтении `char` функцией `scanf` читается следующий символ, даже если это пробел или перевод строки. Так можно делать посимвольный ввод. При чтении переменной другого типа автоматически пропускаются все пробельные символы (пробелы и переводы строк). Чтобы выполнить пропуск всех пробелов явно, можно написать: `scanf(" ");`

-----

## 2.2 Операторы

Язык С, позволяет писать выражения, в которых используются математические и логические операторы, операторы сравнения и некоторые другие типы операторов. В процессе работы программы выражения вычисляются: программа выполняет действия, которые эти операторы обозначают.

Полагаю, что смысл такого выражения ясен любому, кто дочитал эту книгу до этого места:
`x * 2 + a`

Раз мы пишем в императивном стиле, то вычисленные значения выражений нужно уметь присваивать переменным. Для этого нам понадобится оператор присваивания, в качестве которого используется одиночный символ равенства «=».
`n = x * 2 + a;`

В то же время оператором сравнения значений выступает знак, составленный из двух таких символов «==». Будьте внимательны с этими операторами (особенно, если ранее вы писали на языке, где эти операторы имели другой смысл). Если случайно перепутаете эти два оператора, то ошибку в коде визуально будет найти нелегко\!

```c
n = x * 2 + a; // Присваиваем.
m == x * 2 + a; // Сравниваем значения.
```

Также есть такие операторы изменения, которые позволяют в некоторых случаях сделать код более лаконичным:

`a += b;` // Эквивалентно: a = a + b.

`a -= b;`

`a *= b; // и т.д.`

Если значения нужно изменить на единицу, то на помощь придут операторы инкремента и декремента:

`i++;` // Эквивалентно: i += 1; ПОСТинкремент.

`++i;` // Эквивалентно: i += 1; ПРЕинкремент.

`i--;` // Эквивалентно: i -= 1; ПОСТдекремент.

`--i;` // Эквивалентно: i -= 1; ПРЕдекремент.

Разница между постинкрементом и преинкрементом заключается в том, какое значение возвращает выражение. При постинкременте возвращается старое значение изменяемой переменной, а при преинкременте — уже новое изменённое значение.

```c
printf("%d", i++); // Выведется старое значение, а переменная станет больше на 1.
printf("%d", ++i); // Переменная увеличится, и выведется новое значение.
```

Такое использование будет важно при работе с индексами и значениями элементов массивов:
`arr[k++] = x;`

`x = arr[--k];`

-----

## 2.3 Блоки

Блоки группируют действия. Все действия в блоке будут выполняться в том порядке, в котором они написаны. Чтобы объединить действия в блок в языке С используются фигурные скобки:

```c
{
    int t = a;
    a = b;
    b = t;
}
```

Видим, что внутри блока могут быть объявлены переменные. Такие переменные называются локальными и имеют ограниченные области видимости (и жизни): от объявления до конца текущего блока. Блоки могут быть вложенными, можно заводить блок просто так без цикла или условия.

-----

## 2.4 Функции

Программа на языке С состоит из некоторого количества функций. Точкой входа в программу является функия с названием `main`. Далее эта функция может вызывать другие функции, которые в свою очередь также могут вызывать какие-то функции, и т.д. Когда одна функция вызывает другую, говорят, что она передаёт ей управление. Это значит, что она как бы «делает паузу», дожидаясь, пока вызванная функция не завершит свою работу (и вернёт результат). Таким образом функции, которые последовательно друг друга вызвали, образуют некий стек. Такой стек функций называют стеком вызовов.

Синтаксис для определения функции:

```c
имя_типа имя_функции (/* Тут может быть список аргументов */) {
    /* Тело функции */
}
```

Список аргументов представляет собой последовательность объявлений переменных, разделённых запятыми. Список может быть пустым, но даже в этом случае наличие скобок обязательно.

Чтобы вызвать функцию нужно написать её имя и затем в скобках список переданных ей значений аргументов. Значения аргументов могут определяться любыми выражениями, главное, чтобы тип выражения совпадал в типом соответствующего аргумента функции или мог быть к нему приведён.

Функция возвращает значение, используя ключевое слово `return`, после которого следует выражение, определяющее возвращаемое значение. Функция может не возвращать никакого значения, тогда в качестве её типа должен быть использован специальный «пустой» тип `void`. Впрочем, даже в `void`-функции можно использовать слово `return` (без какого-либо выражения) для того, чтобы немедленно выйти из этой функции.

-----

## 2.5 Условия

Конструкция `if`/`else if`/`else` в общем виде имеет следующий синтаксис:

```c
if (/* Условие 1 */) { /* ... */ }
else if (/* Условие 2 */) { /* ... */ }
else if (/* Условие 3 */) { /* ... */ }
else { /* ... */ }
```

Условия вычисляются по очереди сверху вниз. Как только условие оказывается верным, соответствующее тело выполняется, после чего выполнение выходит в самый конец конструкции. Всегда выполняется ровно одно тело, условия вычисляются лишь до тех пор, пока одно из них не окажется верным.

Специального булевого типа в языке C нет. Условие внутри `if` считается:

* **ложью**: если его значение равно нулю;
* **истиной**: если значение не равно нулю.

Сравнения и логические операторы всегда возвращают целое значение: 0 или 1.

Операторы логического «И», логического «ИЛИ» и отрицания:

* `x && y` — истинно, когда истинны оба значения x и y;
* `x || y` — истинно, когда истинно хотя бы одно из значений x и y;
* `!x` — истинно, когда x ложно.

Приоритеты операций: арифметика выполняется раньше сравнений, сравнения выполняются перед логическими операторами.

* `*` и `/` (и `%`) раньше, чем `+` и `-` (как в математике).
* `!` раньше, чем `&&`, а он в свою очередь раньше, чем `||` (как в математике).

Порядок выполнения бинарных операторов с одинаковым приоритетом: слева направо (как в математике); за исключением операторов присваивания, которые наоборот будут выполняться справа налево:

```c
a = b = c; // Сначала b = c; потом a = b.
```

При необходимости можно поменять порядок, заключив подвыражение в скобки. В целом лучше ставить скобки во всех случаях, за исключением совсем уж очевидных, так вы снизите вероятность допустить ошибку, а у человека, который будет читать ваш код, будет меньше вопросов.

**Сокращённое вычисление логических выражений.** При вычислении логического «И» или «ИЛИ» всегда сначала вычисляется левый аргумент. Если результат выражения можно определить по значению левого аргумента, то правый аргумент не вычисляется\! Например, если левый аргумент логического `И` оказался ложью, то ложью будет и всё условие целиком; значение правого аргумента никак не повлияет на результат, значит его вычислять не нужно. Это свойство логических операторов будет очень важно при работе с массивами и указателями, поскольку мы можем первым делом (в левом аргументе) проверить, например, что указатель валиден, и только при условии, что это так, обращаться по этому указателю (в противном случае мы рискуем сделать серьёзную ошибку).

-----

## 2.6 Тернарный оператор

Этот оператор принмает три аргумента: условие и две альтернативы. Значение условия определяет, какая из альтернатив будет вычислена, и её значение определит значение, которое вернёт сам тернарный оператор. Является удобной заменой `if`/`else`, особенно когда значение потом сразу где-то используется:

`int result = условие ? значение_если_истина : значение_если_ложь;`

-----

## 2.7 Циклы

### 2.7.1 Цикл while

Этот цикл по своему синтаксису схож с конструкцией `if` (у которого отсутствует `else`). По смыслу `while` отличается от `if`’а тем, что если условие выполняется, то его тело будет выполняться не единожды, а пока условие не перестанет выполняться.

```c
while (/* Условие */) {
    /* Тело цикла */
}
```

### 2.7.2 Цикл do-while

Это цикл с постусловием. Его тело исполняется всегда хотя бы единожды, а первая проверка условия выполняется только после выполения тела.

```c
do {
    /* Тело цикла */
} while (/* Условие */);
```

### 2.7.3 Цикл for

Цикл с двумя дополнительными элементами: инициализацией и действием, которое выполняется перед переходом на следующую итерацию.

```c
for (/* Инициализация */; /* Условие */; /* Переход на следующую итерацию */) {
    /* Тело цикла */
}
```

Любой цикл `for` можно преобразовать к эквивалентному циклу `while`:

```c
/* Инициализация */
while (/* Условие */) {
    /* Тело цикла */
    /* Переход на следующую итерацию */
}
```

Несмотря на то, что цикл `for` не привносит новых возможностей по сравнению с другими типами циклов, он широко используется, благодаря своему удобству для восприятия (блоки инициалиции и перехода позоляют хорошо выразить смысл происходящего в цикле). Вот, например, канонический вариант цикла `for` в C (перебирает целые от 0 до n − 1):

```c
for (int i = 0; i < n; i++) { ... }
```

Но можно в `for` писать и нетривиальные условия, вроде:

```c
for (int x = 0; x <= rad; x++)
    for (int y = 0; x*x + y*y <= rad*rad; y++)
        sum += x * y;
```

Кстати, чтобы организовать бесконечно выполняющийся цикл можно написать вот так:

```c
for (;;) { ... }
```

Если внутри `for`/`while`/`if` одна команда (утверждение), то язык не требует окружать её фигурными скобками:

```c
int sumSquares = 0;
for (int i = 0; i < n; i++)
    sumSquares += i * i;
```

Однако, в угоду стилю кодирования может требоваться окружать фигурными скобками команду всегда. Естественно, в программе можно писать вложенные циклы и `if`-ы.

### 2.7.4 Команды для выхода из цикла

* **continue;**
  Используя данное ключевое слово внутри цикла, можно сделать немедленный переход на следующую итерацию цикла (перед входом в неё условие цикла будет проверено).

* **break;**
  Чтобы сделать немедленный выход из цикла, надо использовать это слово. Заметим, что если мы находимся в нескольких вложенных циклах, то, используя команду `break`, мы выйдем только из самого глубоко вложенного.

* **goto;**
  Если есть необходимость выйти сразу из нескольких циклов, можно использовать команду `goto`:

  ```c
  for (i = 0; i < n; ++i) {
      for (j = 0; j < i; ++j) {
          if (have2stop(i, j)) {
              goto loop_exit; // Перейти к указанной здесь метке.
          }
      }
  }
  loop_exit: // Это называется "метка".
  hereWeAre();
  ```

  `goto` — слово, использованию которого посвящено большое количество споров. Используйте его только в случае, когда без него не обойтись.

-----

## 2.8 switch

В определённых случаях альтернативой цепочке, составленной из `if-else if–else` может выступать конструкция `switch`. `switch` предназначается, для того, чтобы сравнить значение вычисленного выражения с рядом предопределённых заранее известных значений, и имеет следующий синтаксис:

```c
switch (/* Выражение */) {
    case /* Значение 1 */: /* ... */ break;
    case /* Значение 2 */: /* ... */ break;
    case /* Значение 3 */: /* ... */ break;
    default: /* ... */
}
```

Такой код, вычислив выражение, пойдёт сравнивать его значение сначала с первым значением. Если значения совпали, то выполнятся строки кода, находящиеся после двоеточия; если же значения не совпали, то значение выражения будет сравниваться со вторым заданным значением, и т.д. Если значение выражения не совпало ни с одним из заданных значений, то при наличии метки «default» выполнится код, который следует за ней.

Обратите внимание на слова «break», стоящие после каждой секции кода. Если их не поставить, то выполнение кода в соответствующем месте не будет прервано: пойдут выполняться дальнейшие действия не смотря на то, что значение выражения уже не будет равно следующему указанному значению. В некоторых случаях программисты могут этим сознательно пользоваться, но в таком случае крайне желательно оставить в этом месте комментарий, говорящий, что «break» здесь не написан сознательно.

-----

## 2.9 Комментарии

В языке C есть два способа делать комментарии в коде.

1.  **Блочный комментарий** (такие комментарии были в C изначально):

    ```c
    /* Компилятор игнорирует этот текст. */
    ```

2.  **Строчный комментарий**, как следует из названия заканчивается вместе со строкой (перенесено в C99 из C++):

    ```c
    // Комментарии нужны, чтобы делать ваш код более понятным.
    ```

    Впрочем, действие строчного комментария можно распространить на следующую строку, если в конце закомментированной строки поставить символ «бэкслеш» (`\`).
