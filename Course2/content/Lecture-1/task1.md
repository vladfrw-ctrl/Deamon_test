# Задача 1. Эффективный поиск в отсортированном массиве

* **Тема:** Бинарный поиск
* **Входной файл:** input.txt
* **Выходной файл:** output.txt
* **Ограничение по времени:** 1.0 секунда
* **Ограничение по памяти:** 64 МБ

## Условие задачи
Вам даны два массива целых чисел.
Первый массив $A$ размера $N$ содержит элементы, упорядоченные по неубыванию (то есть $A[i] \le A[i+1]$).
Второй массив $B$ размера $K$ содержит запросы — числа, которые необходимо найти в массиве $A$.

Для каждого числа из массива $B$ определите, содержится ли оно в массиве $A$.
Ваше решение должно работать достаточно быстро, чтобы уложиться в лимит времени. Алгоритм с линейным поиском $O(N \cdot K)$ будет слишком медленным при максимальных ограничениях.

## Формат входных данных
1.  В первой строке записаны два целых числа $N$ и $K$ ($1 \le N, K \le 10^5$).
2.  Во второй строке записаны $N$ целых чисел массива $A$ ($-10^9 \le A[i] \le 10^9$). Гарантируется, что массив отсортирован.
3.  В третьей строке записаны $K$ целых чисел массива $B$ ($-10^9 \le B[j] \le 10^9$) — поисковые запросы.

## Формат выходных данных
Выведите $K$ строк. В $j$-й строке выведите `YES`, если число $B[j]$ присутствует в массиве $A$, и `NO` в противном случае.

## Пример

| input.txt | output.txt |
| :--- | :--- |
| **5 3**<br>1 6 8 12 20<br>6 1 100 | **YES**<br>**YES**<br>**NO** |

## Примечания
Для реализации используйте алгоритм бинарного поиска. Вы можете написать его самостоятельно или воспользоваться стандартной функцией `bsearch` из библиотеки `<stdlib.h>` (в языке C) или `std::binary_search` (в C++).
Обратите внимание, что числа могут быть отрицательными и большими, используйте тип `int` (он вмещает до $2 \cdot 10^9$).