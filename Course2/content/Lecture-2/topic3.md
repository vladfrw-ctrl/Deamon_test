# Глава 3: Теория и практика сортировок

## 3.1 Постановка задачи

Дана последовательность чисел $A = \{a_1, a_2, ..., a_n\}$. Требуется найти такую перестановку $A'$, чтобы для любых $i < j$ выполнялось условие $a'_i \le a'_j$.

Сортировка — одна из самых частых операций в программировании. От выбора алгоритма сортировки часто зависит общая производительность системы. Алгоритмы делятся на:
* **Устойчивые (Stable):** Сохраняют относительный порядок равных элементов.
* **Неустойчивые (Unstable):** Порядок равных элементов может измениться.
* **In-place:** Используют константное количество дополнительной памяти $O(1)$.
* **Not-in-place:** Требуют дополнительную память, зависящую от $N$.

-----

## 3.2 Квадратичные сортировки ($O(N^2)$)

Эти алгоритмы просты в реализации, но непригодны для больших $N$ (где $N > 10^4$).

### Сортировка пузырьком (Bubble Sort)
Идея: пробегаем по массиву, сравнивая пары соседних элементов. Если левый больше правого — меняем их местами. После первого прохода самый большой элемент гарантированно «всплывает» в конец массива.
В худшем случае (массив отсортирован наоборот) мы совершим порядка $\frac{N^2}{2}$ сравнений и обменов.

### Сортировка вставками (Insertion Sort)
Идея: мы поддерживаем отсортированную часть массива слева. Берем следующий элемент и «вставляем» его на нужное место в левой части, сдвигая остальные элементы.
*Лучший случай:* $O(N)$ (массив уже отсортирован).
*Худший случай:* $O(N^2)$.
Именно этот алгоритм часто используется для сортировки очень маленьких массивов (например, $N < 32$) внутри более сложных алгоритмов (как часть QuickSort).

-----

## 3.3 Эффективные сортировки ($O(N \log N)$)

Для обработки миллионов элементов требуются алгоритмы класса «Разделяй и властвуй».

### Сортировка слиянием (Merge Sort)
Алгоритм:
1.  Разделить массив пополам.
2.  Рекурсивно отсортировать левую и правую половины.
3.  **Слияние (Merge):** Пройтись двумя указателями по двум отсортированным половинам, выбирая меньший элемент и записывая его во временный массив.

Сложность всегда $O(N \log N)$, так как глубина рекурсии равна $\log N$, а на каждом уровне мы выполняем линейную работу по слиянию.
Главный недостаток: требует $O(N)$ дополнительной памяти.

### Быстрая сортировка (Quick Sort)
Самый популярный алгоритм на практике (используется в `qsort` в C и `std::sort` в C++).
Алгоритм:
1.  Выбрать опорный элемент (**pivot**).
2.  **Partitioning:** Переставить элементы так, чтобы все числа меньше pivot оказались слева, а больше — справа.
3.  Рекурсивно запустить процесс для левой и правой частей.

**Сложность:**
* В среднем: $O(N \log N)$.
* В худшем случае: $O(N^2)$ (если каждый раз выбирать pivot неудачно, например, минимум или максимум массива).

Для борьбы с худшим случаем используют рандомизированный выбор pivot или медиану трех. Quick Sort работает быстрее Merge Sort на практике, так как эффективнее использует кэш процессора и не требует дополнительной памяти.

-----

## 3.4 Сортировка подсчетом (Counting Sort)

Если мы знаем, что числа в массиве лежат в небольшом диапазоне (например, от 0 до 1000), можно отсортировать массив за **линейное время** $O(N)$.
Мы просто заводим массив счетчиков, подсчитываем, сколько раз встречается каждое число, а затем восстанавливаем массив. Это пример того, как знание природы данных позволяет преодолеть теоретический предел сортировок сравнением $O(N \log N)$.