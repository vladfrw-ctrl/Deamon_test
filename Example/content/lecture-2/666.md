# Глава 3: Массивы и указатели

## 3.1 Массивы

**Массив** — это особый тип переменной, представляющий собой последовательность пронумерованных ячеек. Каждая ячейка может хранить своё значение, но все ячейки имеют одинаковый тип, указанный в объявлении массива. Ячейки также обычно называют «элементами» массива.

Каждый элемент имеет номер (индекс), по которому к этому элементу можно обращаться: читать или писать. Индексы отсчитываются с нуля до N-1, где N — это общее количество элементов массива. Это количество мы будем называть «размером» или «длиной» массива.

Так как известно, что все элементы массива размещаются в памяти подряд и имеют одинаковый размер, то по индексу элемента можно эффективно вычислить, где он должен находиться. Это значит, что обращение к элементу массива по индексу — это очень быстрая операция.

Объявление массива делается следующим образом:
`базовый_тип имя_переменной[длина];`

```c
// Объявляем массив из 200 int'ов:
int arr[200];
```

Отметим что:

1.  Размер массива должен быть известен во время компиляции (нельзя писать `int a[n]`, где n — имя переменной).
2.  Большие массивы лучше объявлять вне `main` (и вообще вне функций), иначе программа может «упасть» либо сразу на старте, либо при вызове функции.

**Инициализация:**

```c
// В arr может быть записан мусор:
int arr[10];

// Массив с пятью заданными значениями:
int arr[5] = {1, 3, 2, 2, 5};

// Компилятор сам определит размер по количеству элементов:
double arr[] = {1.0, 3.0, 2.3};

// Остальные элементы зануляются:
int arr[12] = {1, 2, 3, 5};

// Массив зануляется полностью:
int arr[2000] = {0};
```

**Индексация:** `arr[k]` — k-ый элемент массива arr. Примеры:

```c
// Читаем 3-ий элемент arr,
// прибавляем 7, записываем сумму в res:
int res = arr[3] + 7;

// В цикле в каждый элемент запишем его индекс:
for (int i = 0; i < n; i++) {
    arr[i] = i;
}

// Можно писать выражения для индекса:
arr[i] += arr[i * i + i];

for (int i = 0; i < n; i++) {
    // Ничто не мешает использовать
    // элемент массива в качестве индекса:
    arr[index[i]] = i;
}
```

При выходе индекса за пределы массива (`k < 0 || k > N - 1`) может происходить что угодно\! Обычно происходит одно из перечисленного:

1.  Попадаем сильно мимо — программа сразу падает с ошибкой «access violation».
2.  Попадаем в мусор — читаем оттуда что попало, запись ни на что не влияет, программа работает дальше.
3.  Попадаем в другую свою переменную — читаем оттуда другие данные, запись изменяет другие переменные.

**Простой пример (номер минимального элемента):**

```c
int arr[1010];

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }
    int best_value = 1000000000;
    int best_index = 0;
    for (int i = 0; i < n; i++) {
        if (best_value > arr[i]) {
            best_value = arr[i];
            best_index = i;
        }
    }
    printf("%d", best_index);
}
```

-----

## 3.2 Многомерные массивы

Что делать если, например, нужно хранить матрицу (таблицу), 100 строк и 500 столбцов?

Можно упаковать её в обычный массив, но обращаться к элементам будет не очень удобно:

```c
int matr[100 * 500];
// Обращаемся к элементу, находящемся
// в i-ой строке, j-ом столбце.
int q = matr[i * 500 + j];
```

Лучшим решением будет завести двумерный массив в С:

```c
int matr[100][500];
int q = matr[i][j];
```

Элементы `matr` расположены в памяти ровно так же, как в показанном выше одномерном массиве. Можно делать массивы любых размерностей:

```c
int my_array_5D[2][7][64][100][8];
```

-----

## 3.3 Указатели

На языке С практически невозможно написать программу сложнее, чем «Hello World», не используя указатели.

Вся память может рассматриваться, как массив байтов. Все переменные программы хранятся в нём. Все байты памяти пронумерованы, значит все переменные имеют свой адрес — номер ячейки, где размещён первый байт переменной.

**«Указатель»** — это адрес чего-то в памяти. Для указателя задано, на значение какого типа он должен указывать.

**Объявление указателя:**
`базовый_тип* имя_переменной;`

```c
// Объявляем переменную — указатель на int:
int* ptr;
```

**Взятие адреса/указателя (оператор «&»):**

```c
int x;
// В ptr запишем адрес переменной х.
ptr = &x;
```

**Разыменование указателя (оператор «\*»):**

```c
// Читаем из памяти по адресу ptr значение типа int.
int res = *ptr;
```

**Указатель на указатель:**

```c
// В pp будет хранится адрес самого указателя ptr.
int** pp = &ptr;
```

**Арифметика на указателях.** К указателю можно прибавить или отнять от него целое число:

* `(ptr + k)` — указатель, который указывает на k-ый элемент после ptr.

**Индексация по указателю:**

* `ptr[k]` эквивалентно `*(ptr + k)`
* `ptr[0]` эквивалентно `*ptr`

Переменная-массив в программе может автоматически превращаться в указатель:

```c
int arr[128];
// В ptr запишется адрес массива arr.
int* ptr = arr;
```

Теперь `arr[k]` эквивалентно `ptr[k]`.

Также можно вычислить разность указателей, если они одного типа:

```c
int *ptr_a, *ptr_b;
int k = ptr_b - ptr_a; // k = (адрес(ptr_b) - адрес(ptr_a)) / размер(*ptr_a)
```

**Нулевой указатель** (0) указывает «ни на что». Ни читать, ни писать по нулевому указателю нельзя.

-----